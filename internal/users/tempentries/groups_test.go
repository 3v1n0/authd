package tempentries

import (
	"slices"
	"testing"

	"github.com/stretchr/testify/require"
	"github.com/ubuntu/authd/internal/testutils/golden"
	"github.com/ubuntu/authd/internal/users/idgenerator"
	"github.com/ubuntu/authd/internal/users/types"
)

func TestRegisterGroup(t *testing.T) {
	t.Parallel()

	ownerUID := uint32(54321)
	defaultGroupName := "authd-temp-groups-test"
	gidToGenerate := uint32(12345)

	tests := map[string]struct {
		groups         []string
		gidsToGenerate []uint32

		wantErr  []bool
		wantGIDs []uint32
	}{
		"Successfully_register_a_new_group": {},
		"Successfully_register_a_group_if_the_first_generated_GID_is_already_in_use": {
			gidsToGenerate: []uint32{0, gidToGenerate}, // GID 0 (root) always exists
			wantGIDs:       []uint32{gidToGenerate},
		},
		"Successfully_register_a_group_if_the_first_generated_GID_is_already_registered": {
			groups:         []string{defaultGroupName, "other-group"},
			gidsToGenerate: []uint32{gidToGenerate, gidToGenerate, gidToGenerate + 1},
			wantGIDs:       []uint32{gidToGenerate, gidToGenerate + 1},
		},

		"Error_when_name_is_already_in_use": {groups: []string{"root"}, wantErr: []bool{true}},
		"Error_when_registering_a_group_with_the_same_name": {
			groups:  []string{defaultGroupName, defaultGroupName},
			wantErr: []bool{false, true},
		},
	}
	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			if len(tc.groups) == 0 {
				tc.groups = append(tc.groups, defaultGroupName)
			}

			if tc.gidsToGenerate == nil {
				gid := gidToGenerate
				for range tc.groups {
					tc.gidsToGenerate = append(tc.gidsToGenerate, gid)
					gid++
				}
			}
			if tc.wantGIDs == nil {
				tc.wantGIDs = tc.gidsToGenerate
			}
			if tc.wantErr == nil {
				tc.wantErr = make([]bool, len(tc.groups))
			}

			wantRegistered := 0
			var registeredGIDs []uint32
			cleanupFunctions := map[uint32]func(){}

			t.Log("GIDs to generate", tc.gidsToGenerate)
			idGeneratorMock := &idgenerator.IDGeneratorMock{GIDsToGenerate: tc.gidsToGenerate}
			records := NewTemporaryRecords(idGeneratorMock)

			for idx, groupName := range tc.groups {
				t.Logf("Registering group %q", groupName)
				gid, cleanup, err := records.RegisterGroupForUser(ownerUID, groupName)
				if tc.wantErr[idx] {
					require.Error(t, err, "RegisterGroup should return an error, but did not")
					continue
				}

				require.NoError(t, err, "RegisterGroup should not return an error, but did")
				t.Cleanup(cleanup)

				isDuplicated := slices.Contains(tc.groups[0:idx], groupName)
				if !isDuplicated {
					wantRegistered++
				}

				if isDuplicated {
					require.Contains(t, registeredGIDs, gid, "GID %d has been already registered!", gid)
				} else {
					require.NotContains(t, registeredGIDs, gid, "GID %d has not been already registered!", gid)
				}

				wantGID := tc.wantGIDs[wantRegistered-1]
				registeredGIDs = append(registeredGIDs, gid)
				cleanupFunctions[gid] = cleanup

				require.NoError(t, err, "RegisterGroup should not return an error, but did")
				require.Equal(t, wantGID, gid, "GID should be the one generated by the IDGenerator")
				require.Equal(t, wantRegistered, len(records.groups),
					"Number of groups registered, users should be %d", wantRegistered)

				// Check that the temporary group was created
				group, err := records.GroupByID(gid)
				require.NoError(t, err, "GroupByID should not return an error, but did")

				var goldenOptions []golden.Option
				if idx > 0 {
					goldenOptions = append(goldenOptions, golden.WithSuffix("_"+groupName))
				}
				checkGroup(t, group, goldenOptions...)
			}

			if wantRegistered == 0 {
				return
			}

			for idx, groupName := range tc.groups {
				isDuplicated := slices.Contains(tc.groups[0:idx], groupName)
				if !isDuplicated {
					wantRegistered--
				}

				removeGID := registeredGIDs[len(registeredGIDs)-wantRegistered-1]
				t.Logf("Removing group %q for GID %v", groupName, removeGID)
				cleanupFunctions[removeGID]()

				// Check that the temporary group was deleted
				_, err := records.GroupByID(removeGID)
				require.Error(t, err, "GroupByID should return an error, but did not")
			}
		})
	}
}

func TestGroupByIDAndName(t *testing.T) {
	t.Parallel()

	ownerUID := uint32(54321)
	groupName := "authd-temp-groups-test"
	gidToGenerate := uint32(12345)

	tests := map[string]struct {
		registerGroup       bool
		groupAlreadyRemoved bool
		byName              bool

		wantErr bool
	}{
		"Successfully_get_a_group_by_ID":   {registerGroup: true},
		"Successfully_get_a_group_by_name": {registerGroup: true, byName: true},

		"Error_when_group_is_not_registered_-_GroupByID":   {wantErr: true},
		"Error_when_group_is_not_registered_-_GroupByName": {byName: true, wantErr: true},
		"Error_when_group_is_already_removed_-_GroupByID": {
			registerGroup:       true,
			groupAlreadyRemoved: true,
			wantErr:             true,
		},
		"Error_when_group_is_already_removed_-_GroupByName": {
			registerGroup:       true,
			groupAlreadyRemoved: true,
			byName:              true,
			wantErr:             true,
		},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			t.Parallel()

			idGeneratorMock := &idgenerator.IDGeneratorMock{GIDsToGenerate: []uint32{gidToGenerate}}
			records := NewTemporaryRecords(idGeneratorMock)

			if tc.registerGroup {
				gid, cleanup, err := records.RegisterGroupForUser(ownerUID, groupName)
				require.NoError(t, err, "RegisterGroup should not return an error, but did")
				require.Equal(t, gidToGenerate, gid, "GID should be the one generated by the IDGenerator")

				if tc.groupAlreadyRemoved {
					cleanup()
				} else {
					defer cleanup()
				}
			}

			var group types.GroupEntry
			var err error
			if tc.byName {
				group, err = records.GroupByID(gidToGenerate)
			} else {
				group, err = records.GroupByName(groupName)
			}

			if tc.wantErr {
				require.Error(t, err, "GroupByID should return an error, but did not")
				return
			}
			require.NoError(t, err, "GroupByID should not return an error, but did")
			checkGroup(t, group)
		})
	}
}

func checkGroup(t *testing.T, group types.GroupEntry, options ...golden.Option) {
	t.Helper()

	require.Empty(t, group.Passwd, "Passwd should be empty")

	golden.CheckOrUpdateYAML(t, group, options...)
}
